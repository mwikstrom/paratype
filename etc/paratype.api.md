## API Report File for "paratype"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export const anyType: Type<unknown>;

// @public
export function arrayType<T>(itemType: Type<T>): Type<T[]>;

// @public
export const binaryType: Type<ArrayBufferLike>;

// @public
export const booleanType: Type<boolean>;

// @public
export function classType<T extends TypeClass<I>, I extends TypeInstance>(ctor: T): Type<I>;

// @public
export function constType<T extends string>(fixed: T): Type<T>;

// @public
export function customClassType<T extends Partial<Equatable>, Args extends unknown[] = unknown[]>(ctor: {
    new (...args: Args): T;
}, fromJsonValue: (this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray) => T, toJsonValue: (this: void, value: T, error?: ErrorCallback, path?: PathArray) => JsonValue): Type<T>;

// @public
export function discriminatorType<Key extends string & keyof TypeOf<Union[keyof Union]>, Union extends Record<string, Type>>(key: Key, union: Union): Type<TypeOf<Union[keyof Union]>>;

// @public
export function enumType<V extends string>(values: V[]): Type<V>;

// @public
export interface Equatable {
    // (undocumented)
    equals(other: unknown): boolean;
}

// @public
export type ErrorCallback = (message: string) => Error;

// @public
export function formatPath(path: PathArray): string;

// @public
export const frozen: <T extends new (...args: any[]) => any>(constructor: T) => T;

// @public
export const integerType: Type<number>;

// @public
export function isType(value: unknown): value is Type;

// @public
export type JsonArray = Array<JsonValue>;

// @public
export interface JsonObject extends Record<string, JsonValue> {
}

// @public
export type JsonPrimitive = string | number | boolean | null;

// @public
export type JsonValue = JsonPrimitive | JsonArray | JsonObject;

// @public
export const jsonValueType: Type<JsonValue>;

// @public
export function lazyType<T>(init: () => Type<T>): Type<T>;

// @public
export function mapType<T>(valueType: Type<T>): Type<Map<string, T>>;

// @public
export const nonNegativeIntegerType: Type<number>;

// @public
export const nullType: Type<null>;

// @public
export const numberType: Type<number>;

// @public
export type OptionalPropsOf<T> = string & Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? never : K;
}[keyof T], undefined>;

// @public
export type ParameterTypeDecorator = (target: ValidationTarget, propertyKey: string | symbol | undefined, parameterIndex: number) => void;

// @public
export type PathArray = Array<string | number>;

// @public
export const positiveIntegerType: Type<number>;

// @public
export type Predicate<T> = (value: T) => boolean;

// @public
export type PropertyTypes<T extends Record<string, unknown>> = {
    [P in keyof T]-?: Type<Exclude<T[P], undefined>>;
};

// @public
export function RecordClass<Props>(propsType: RecordType<Props>): RecordConstructor<Props>;

// @public
export function RecordClass<Props, Data>(propsType: RecordType<Props>, dataType: Type<Data>, dataToProps: (data: Data) => Props, propsToData: (props: Props) => Data): RecordConstructor<Props, Data>;

// @public
export type RecordConstructor<Props, Data = Props> = {
    new (input: Props | Data): RecordObject<Props, Data> & Readonly<Props>;
    readonly propsType: RecordType<Props>;
    readonly dataType: Type<Data>;
};

// @public
export class RecordObject<Props, Data = Props> {
    equals(value: Props | Data): boolean;
    get<K extends keyof Props>(key: K): Props[K];
    get(key: string): unknown | undefined;
    has<K extends keyof Props>(key: K, value?: Props[K]): boolean;
    has(key: string, value?: unknown): boolean;
    merge(props: Partial<Props>): this;
    set<K extends keyof Props>(key: K, value: Props[K]): this;
    toData(): Data;
    unmerge(props: Partial<Pick<Props, OptionalPropsOf<Props>>>): this;
    unset(...keys: OptionalPropsOf<Props>[]): this;
}

// @public
export interface RecordOptions<O extends string[] = []> {
    optional?: O;
}

// @public
export interface RecordType<T> extends Type<T> {
    asPartial(this: void): RecordType<Partial<T>>;
    getPropertyNames(): Iterable<keyof T>;
    getPropertyType(key: string): Type<unknown> | undefined;
    // (undocumented)
    getPropertyType<K extends keyof T>(key: K): Type<T[K]>;
    isOptional(key: string): boolean;
    pick<S extends Partial<T>>(source: S): Pick<S, keyof T>;
    withOptional<K extends (string & keyof T)>(...keys: K[]): RecordType<Omit<T, K> & Partial<Pick<T, K>>>;
}

// @public
export function recordType<T extends Record<string, unknown>>(properties: PropertyTypes<T>): RecordType<T>;

// @public
export function restType(type: Type<unknown>): ParameterTypeDecorator;

// @public
export const stringType: Type<string>;

// @public
export const timestampType: Type<Date>;

// @public
export interface Type<T = unknown> {
    assert(this: void, value: unknown, error?: ErrorCallback, path?: PathArray): asserts value is T;
    equals(this: void, first: T, second: unknown): second is T;
    error(this: void, value: unknown, path?: PathArray, shallow?: boolean): string | undefined;
    fromJsonValue(this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray): T;
    frozen(this: void): Type<Readonly<T>>;
    restrict(this: void, message: string, predicate: Predicate<T>): Type<T>;
    test(this: void, value: unknown, path?: PathArray): value is T;
    toJsonValue(this: void, value: T, error?: ErrorCallback, path?: PathArray): JsonValue;
}

// @public
export function type(type: Type<unknown>): ParameterTypeDecorator;

// @public
export interface TypeClass<I extends TypeInstance> {
    // (undocumented)
    new (...args: unknown[]): I;
    // (undocumented)
    fromJsonValue(this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray): I;
}

// @public
export interface TypeInstance extends Partial<Equatable> {
    // (undocumented)
    toJsonValue(error?: ErrorCallback, path?: PathArray): JsonValue;
}

// @public
export type TypeOf<T extends Type<unknown> | undefined> = T extends Type<infer V> ? V : never;

// @public
export function unionType<T extends Type<unknown>[]>(...types: T): Type<TypeOf<T[number]>>;

// @public
export function validating<T extends ValidationTarget>(constructor: T): T;

// @public
export type ValidationTarget = {
    new (...args: any[]): any;
};

// @public
export const voidType: Type<void>;

// @public
export function withClassType<T extends RecordObject<Props, Data>, Props, Data>(target: {
    new (input: Props | Data): T;
    readonly classType: Type<T>;
    readonly dataType: Type<Data>;
}): void;

```
