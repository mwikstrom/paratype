## API Report File for "paratype"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export const anyType: Type<unknown>;

// @public
export function arrayType<T>(itemType: Type<T>): Type<T[]>;

// @public
export const binaryType: Type<ArrayBufferLike>;

// @public
export const booleanType: Type<boolean>;

// @public
export function classType<T extends TypeClass<I>, I extends TypeInstance>(ctor: T): Type<I>;

// @public
export function constType<T extends string>(fixed: T): Type<T>;

// @public
export function discriminatorType<Key extends string & keyof TypeOf<Union[keyof Union]>, Union extends Record<string, Type>>(key: Key, union: Union): Type<TypeOf<Union[keyof Union]>>;

// @public
export function enumType<V extends string>(values: V[]): Type<V>;

// @public
export type ErrorCallback = (message: string) => Error;

// @public
export function formatPath(path: PathArray): string;

// @public
export const integerType: Type<number>;

// @public
export function isType(value: unknown): value is Type;

// @public
export type JsonArray = Array<JsonValue>;

// @public
export interface JsonObject extends Record<string, JsonValue> {
}

// @public
export type JsonPrimitive = string | number | boolean | null;

// @public
export type JsonValue = JsonPrimitive | JsonArray | JsonObject;

// @public
export const jsonValueType: Type<JsonValue>;

// @public
export function mapType<T>(valueType: Type<T>): Type<Map<string, T>>;

// @public
export const nonNegativeIntegerType: Type<number>;

// @public
export const nullType: Type<null>;

// @public
export const numberType: Type<number>;

// @public
export type PathArray = Array<string | number>;

// @public
export const positiveIntegerType: Type<number>;

// @public
export type Predicate<T> = (value: T) => boolean;

// @public
export type PropertyTypes<T extends Record<string, unknown>, O extends (string & keyof T)[] = []> = {
    [P in keyof T]-?: P extends O[number] ? Type<Exclude<T[P], undefined>> : Type<T[P]>;
};

// @public
export interface RecordOptions<O extends string[] = []> {
    optional?: O;
}

// @public
export function recordType<T extends Record<string, unknown>, O extends (string & keyof T)[] = []>(properties: PropertyTypes<T, O>, options?: RecordOptions<O>): Type<WithRecordOptions<T, O>>;

// @public
export const stringType: Type<string>;

// @public
export const timestampType: Type<Date>;

// @public
export interface Type<T = unknown> {
    assert(this: void, value: unknown, error?: ErrorCallback, path?: PathArray): asserts value is T;
    error(this: void, value: unknown, path?: PathArray, shallow?: boolean): string | undefined;
    fromJsonValue(this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray): T;
    restrict(this: void, message: string, predicate: Predicate<T>): Type<T>;
    test(this: void, value: unknown, path?: PathArray): value is T;
    toJsonValue(this: void, value: T, error?: ErrorCallback, path?: PathArray): JsonValue;
}

// @public
export interface TypeClass<I extends TypeInstance> {
    // (undocumented)
    new (...args: any): I;
    // (undocumented)
    fromJsonValue(this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray): I;
}

// @public
export interface TypeInstance {
    // (undocumented)
    toJsonValue(error?: ErrorCallback, path?: PathArray): JsonValue;
}

// @public
export type TypeOf<T extends Type<unknown> | undefined> = T extends Type<infer V> ? V : never;

// @public
export const voidType: Type<void>;

// @public
export type WithRecordOptions<T extends Record<string, unknown>, O extends (string & keyof T)[] = []> = {
    [P in Exclude<keyof T, O[number]>]-?: T[P];
} & {
    [P in O[number]]?: T[P];
};

```
