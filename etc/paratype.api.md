## API Report File for "paratype"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export const anyType: Type<unknown>;

// @public
export function arrayType<T>(itemType: Type<T>): Type<T[]>;

// @public
export const binaryType: Type<ArrayBufferLike>;

// @public
export const booleanType: Type<boolean>;

// @public
export function classType<T extends TypeClass<I>, I extends TypeInstance>(ctor: T): Type<I>;

// @public
export function constType<T extends string>(fixed: T): Type<T>;

// @public
export function customClassType<T extends Partial<Equatable>, Args extends unknown[] = unknown[]>(ctor: {
    new (...args: Args): T;
}, fromJsonValue: (this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray) => T, toJsonValue: (this: void, value: T, error?: ErrorCallback, path?: PathArray) => JsonValue): Type<T>;

// @public
export function discriminatorType<Key extends string & keyof TypeOf<Union[keyof Union]>, Union extends Record<string, Type>>(key: Key, union: Union): Type<TypeOf<Union[keyof Union]>>;

// @public
export function enumType<V extends string>(values: V[]): Type<V>;

// @public
export interface Equatable {
    // (undocumented)
    equals(other: unknown): boolean;
}

// @public
export type ErrorCallback = (message: string) => Error;

// @public
export function formatPath(path: PathArray): string;

// @public
export const integerType: Type<number>;

// @public
export function isType(value: unknown): value is Type;

// @public
export type JsonArray = Array<JsonValue>;

// @public
export interface JsonObject extends Record<string, JsonValue> {
}

// @public
export type JsonPrimitive = string | number | boolean | null;

// @public
export type JsonValue = JsonPrimitive | JsonArray | JsonObject;

// @public
export const jsonValueType: Type<JsonValue>;

// @public
export function lazyType<T>(init: () => Type<T>): Type<T>;

// @public
export function mapType<T>(valueType: Type<T>): Type<Map<string, T>>;

// @public
export const nonNegativeIntegerType: Type<number>;

// @public
export const nullType: Type<null>;

// @public
export const numberType: Type<number>;

// @public
export type PathArray = Array<string | number>;

// @public
export const positiveIntegerType: Type<number>;

// @public
export type Predicate<T> = (value: T) => boolean;

// @public
export type PropertyTypes<T extends Record<string, unknown>> = {
    [P in keyof T]-?: Type<Exclude<T[P], undefined>>;
};

// @public (undocumented)
function Record_2<T>(type: RecordType<T>): RecordClass<T>;
export { Record_2 as Record }

// @public (undocumented)
export type RecordClass<T> = {
    new (props: T): RecordInstance<T>;
};

// @public (undocumented)
export type RecordInstance<T> = (Readonly<T> & Omit<RecordInterface<T>, (Unsettable<T> extends never ? ("unmerge" | "unset") : never)>);

// @public (undocumented)
export interface RecordInterface<T> {
    // (undocumented)
    equals(other: unknown): boolean;
    // (undocumented)
    get<K extends keyof T>(key: K): T[K];
    // (undocumented)
    get(key: string): unknown | undefined;
    // (undocumented)
    has<K extends keyof T>(key: K, value?: T[K]): boolean;
    // (undocumented)
    has(key: string, value?: unknown): boolean;
    // (undocumented)
    merge(props: Partial<T>): this;
    // (undocumented)
    set<K extends keyof T>(key: K, value: T[K]): this;
    // (undocumented)
    unmerge(props: Required<Pick<T, Unsettable<T>>>): this;
    // (undocumented)
    unset(...keys: Unsettable<T>[]): this;
}

// @public
export interface RecordOptions<O extends string[] = []> {
    optional?: O;
}

// @public
export interface RecordType<T> extends Type<T> {
    asPartial(this: void): RecordType<Partial<T>>;
    getPropertyNames(): Iterable<string>;
    getPropertyType(key: string): Type<unknown> | undefined;
    isOptional(key: string): boolean;
    pick<S extends Partial<T>>(source: S): Pick<S, keyof T>;
    withOptional<K extends (string & keyof T)>(...keys: K[]): RecordType<Omit<T, K> & Partial<Pick<T, K>>>;
}

// @public
export function recordType<T extends Record<string, unknown>>(properties: PropertyTypes<T>): RecordType<T>;

// @public
export const stringType: Type<string>;

// @public
export const timestampType: Type<Date>;

// @public
export interface Type<T = unknown> {
    assert(this: void, value: unknown, error?: ErrorCallback, path?: PathArray): asserts value is T;
    equals(this: void, first: T, second: unknown): second is T;
    error(this: void, value: unknown, path?: PathArray, shallow?: boolean): string | undefined;
    fromJsonValue(this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray): T;
    frozen(this: void): Type<Readonly<T>>;
    restrict(this: void, message: string, predicate: Predicate<T>): Type<T>;
    test(this: void, value: unknown, path?: PathArray): value is T;
    toJsonValue(this: void, value: T, error?: ErrorCallback, path?: PathArray): JsonValue;
}

// @public
export interface TypeClass<I extends TypeInstance> {
    // (undocumented)
    new (...args: unknown[]): I;
    // (undocumented)
    fromJsonValue(this: void, value: JsonValue, error?: ErrorCallback, path?: PathArray): I;
}

// @public
export interface TypeInstance extends Partial<Equatable> {
    // (undocumented)
    toJsonValue(error?: ErrorCallback, path?: PathArray): JsonValue;
}

// @public
export type TypeOf<T extends Type<unknown> | undefined> = T extends Type<infer V> ? V : never;

// @public
export function unionType<T extends Type<unknown>[]>(...types: T): Type<TypeOf<T[number]>>;

// @public (undocumented)
export type Unsettable<T> = {
    [K in keyof T]: T[K] extends undefined ? K : never;
}[keyof T];

// @public
export const voidType: Type<void>;

```
